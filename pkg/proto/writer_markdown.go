/*
 * Copyright 2022 Google, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package proto

import (
	"fmt"
	"sort"
	"strconv"
	"strings"
)

const (
	packageTemplate = `
# Package: %s
%s

%s

<!-- Generated by Proto Diagram Tool -->
`
	typeTemplate = `
## %s
%s

%s
`
	mermaidClassDiagramTemplate = "### %s Diagram\n\n```mermaid\nclassDiagram\n%s\n```"
)

func ToMermaid(title string, rt interface{}) string {
	out := ""
	switch t := rt.(type) {
	case *Package:
		out += PackageToMermaid(t)
	case *Enum:
		out += EnumToMermaid(t)
	case *Message:
		out += MessageToMermaid(t)
	case *Service:
		out += ServiceToMermaid(t)
	}
	return fmt.Sprintf(mermaidClassDiagramTemplate, title, out)
}

func EnumToMarkdown(enum *Enum, visualize bool) string {
	enumTable := NewMarkdownTable()
	enumTable.AddHeader("Name", "Ordinal", "Namespace", "Description")
	for _, v := range enum.Values {
		enumTable.Insert(v.Value, strconv.Itoa(v.Ordinal), v.Namespace, string(v.Comment))
	}

	// Convert to a string
	table := enumTable.String()
	if visualize {
		table += "\n" + ToMermaid(enum.Name, enum)
	}
	return fmt.Sprintf(typeTemplate, enum.Name, enum.Comment, table)
}

func MessageToMarkdown(message *Message, visualize bool) string {
	attributeTable := NewMarkdownTable()
	attributeTable.AddHeader("Field", "Type", "Label", "Description")

	sort.Slice(message.Attributes, func(i, j int) bool {
		v := strings.Compare(message.Attributes[i].Name, message.Attributes[j].Name)
		return v < 0
	})

	for _, a := range message.Attributes {
		label := ""
		if a.Map {
			label = "Map"
		} else if a.Repeated {
			label = "Repeated"
		}
		attributeTable.Insert(a.Name, strings.Join(a.Kind, Comma), label, string(a.Comment))
	}

	table := attributeTable.String()
	if visualize {
		table += "\n" + ToMermaid(message.Name, message)
	}

	out := fmt.Sprintf(typeTemplate, message.Name, message.Comment, table)

	for _, e := range message.Enums {
		out += EnumToMarkdown(e, visualize)
	}
	return out
}

func FormatServiceParameter(parameters []*Parameter) string {
	out := ""
	for _, p := range parameters {
		if p.Stream {
			out += fmt.Sprintf("Stream\\<%s\\>", RemoveNameQualification(p.Type))
		} else {
			out += fmt.Sprintf("%s", RemoveNameQualification(p.Type))
		}
	}
	return out
}

func ServiceToMarkdown(s *Service, visualize bool) string {
	methodTable := NewMarkdownTable()
	methodTable.AddHeader("Method", "Parameter (In)", "Parameter (Out)", "Description")
	for _, m := range s.Methods {
		methodTable.Insert(m.Name,
			FormatServiceParameter(m.InputParameters),
			FormatServiceParameter(m.ReturnParameters), string(m.Comment))
	}
	table := methodTable.String()
	if visualize {
		table += "\n" + ToMermaid(s.Name, s)
	}

	return fmt.Sprintf(typeTemplate, s.Name, s.Comment, table)
}

func PackageToMarkDown(p *Package, visualize bool) string {
	out := ""

	if len(p.Services) > 0 {
		out += "\n## Services\n\n"
		for _, s := range p.Services {
			out += ServiceToMarkdown(s, visualize)
		}
	}

	if len(p.Enums) > 0 {
		out += "\n## Enumerations\n\n"
		for _, e := range p.Enums {
			out += EnumToMarkdown(e, visualize)
		}
	}

	// TODO - Add recursion
	if len(p.Messages) > 0 {
		out += "\n## Messages\n\n"
		for _, m := range p.Messages {
			out += MessageToMarkdown(m, visualize)
		}
	}

	out = fmt.Sprintf(packageTemplate, p.Name, p.Comment, out)
	return out
}
